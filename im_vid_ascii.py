# -*- coding: utf-8 -*-
"""Im_Vid_ASCII.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t1riQGiBY85vxBG0Oh-ARR06EPRBXVAK

#All 2 ASCII
<small><i>**Autores**: Santiago Javier Florez, Hancy Esteban Toro

#Librerías
"""

pip install sk-video #conda install -c conda-forge scikit-video

import cv2 as cv #pip install opencv-python
import numpy as np #conda install -c conda-forge scikit-learn
import matplotlib.pyplot as plt
import skvideo.io as sk
import PIL as pl
from PIL import Image
import PIL #pip install Pillow 
import PIL.Image
import PIL.ImageFont
import PIL.ImageOps
import PIL.ImageDraw
from skimage import color
from skimage import io
import random
from os import remove
from google.colab import files
from sklearn.cluster import KMeans

"""#Funciones

Función K-Means
"""

def K_Means(Image, K):
    
    if(len(Image.shape)<3):
      Z = Image.reshape((-1,1))
    elif len(Image.shape)==3:
      Z = Image.reshape((-1,3))
    
    
    # convierte a np.float32
    Z = np.float32(Z)
    
    # define criterio, número de clusters(K) y aplica kmeans()
    criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)
    ret,label,center = cv.kmeans(Z, K, None, criteria, 10, cv.KMEANS_RANDOM_CENTERS)
    
    # Ahora convierte lo anterior a uint8, y rehace la imagen
    center = np.uint8(center)
    res = center[label.flatten()]
    Clustered_Image = res.reshape((Image.shape))
    
    return Clustered_Image

"""Redimensiona la imagen y la escala a grises. """

def k_imagen_grey(Imagen,Clusters):

  Input_Image =Imagen
  #Clustered_Image = K_Means(Input_Image, Clusters)
  Clustered_Image = K_Means(Input_Image, Clusters)
  img = color.rgb2gray(Clustered_Image)


  scale_percent = 50 # porciento del tamaño original
  width = int(img.shape[1] * scale_percent / 100)
  height = int(img.shape[0] * scale_percent / 100)
  dim = (width, height)
 
  # redimensionar imagen
  resized = cv.resize(img, dim, interpolation = cv.INTER_AREA)
                      
  return resized

"""Función que transforma pixeles de color B/N a ASCII."""

def arr2ascii (img,w,h):

  max=img.max()-0.01
  min=img.min()+0.01

  test1=np.chararray((w,h),unicode=True)
  
  for i in range(w):
    for i2 in range(h):
      x = random.randint(0,4)

      if (img[i,i2]>min):
        if (img[i,i2]<max): 
            test1[i,i2] = ASC_med[x]
        elif (img[i,i2]>=max):#pixel blanco 
            test1[i,i2] = ASC_big[x]

      if (img[i,i2]<=min):#pixel oscuro
        test1[i,i2] = ASC_sma[x]

  return test1

"""Función convertir de .txt a .jpg"""

PIXEL_ON = 0  # PIL color a usar como "on"
PIXEL_OFF = 255  # PIL color a usar como "off"

def text_image(text_path, font_path=None):
    
    grayscale = 'L'
    # parse the file into lines
    with open(text_path) as text_file:  # can throw FileNotFoundError
        lines = tuple(l.rstrip() for l in text_file.readlines())

    # choose a font (you can see more detail in my library on github)
    large_font = 20  
    font_path = font_path or 'cour.ttf'  # Courier New. works in windows. linux may need more explicit path
    try:
        font = PIL.ImageFont.truetype(font_path, size=large_font)
    except IOError:
        font = PIL.ImageFont.load_default()
        print('Could not use chosen font. Using default.')

    # make the background image based on the combination of font and lines
    pt2px = lambda pt: int(round(pt * 96.0 / 72))  # convert points to pixels
    max_width_line = max(lines, key=lambda s: font.getsize(s)[0])
    # max height is adjusted down because it's too large visually for spacing
    test_string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    max_height = pt2px(font.getsize(test_string)[1])
    max_width = pt2px(font.getsize(max_width_line)[0])
    height = max_height * len(lines)  # perfect or a little oversized
    width = int(round(max_width + 40))  # a little oversized
    image = PIL.Image.new(grayscale, (width, height), color=PIXEL_OFF)
    draw = PIL.ImageDraw.Draw(image)

    # draw each line of text
    vertical_position = 5
    horizontal_position = 5
    line_spacing = int(round(max_height * 0.8))  # reduced spacing seems better
    for line in lines:
        draw.text((horizontal_position, vertical_position),
                  line, fill=PIXEL_ON, font=font)
        vertical_position += line_spacing
    # crop the text
    c_box = PIL.ImageOps.invert(image).getbbox()
    
 
    image = image.crop(c_box)
    return image

"""No olvidar crear carpeta llamada "Frames"

Caracteres ASCII
"""

ASC_big=['@@','##','&&','WW','MM']
ASC_med=['l','+','1','/','*']
ASC_sma=[',',';','.','-','^']

"""Llamado de funciones para la magia.

#Imagen

Cargar imagen...
"""

uploaded = files.upload() #ejecutar para subir imagen

#Obtener el nombre de la imagen subida
for fn in uploaded.keys():
  print('Subio el archivo "{name}" con tamaño {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#Programa Imagen Completo
imagen_up=plt.imread(fn)
iii = k_imagen_grey(imagen_up,Clusters=3)
iii = arr2ascii(iii,iii.shape[0],iii.shape[1])
np.savetxt('test.txt',iii,fmt='%s')
iii = text_image('test.txt')


#Imagenes
plt.figure(figsize=(10,10))
plt.title('Imagen Original')
plt.imshow (imagen_up)

plt.figure(figsize=(10,10))
plt.title('Imagen Cluster B/N')
plt.imshow(np.asarray(k_imagen_grey( imagen_up,Clusters=3,)),cmap='gray')

plt.figure(figsize=(10,10))
iii = PIL.ImageOps.invert(iii)
plt.title('Imagen ASCII')
plt.imshow(iii, cmap='gray')
iii.save('Output_imagen.jpg')#Ouput_imagen es el resultado y se puede descargar

"""#Vídeo

Ahora vamos con un vídeo...
"""

uploaded_v = files.upload()

#Obtener nombre del vídeo
for fn_v in uploaded_v.keys():
  print('Subio el archivo "{name}" con tamaño {length} bytes'.format(
        name=fn_v, length=len(uploaded_v[fn_v])))

videodata = sk.vread(fn_v)
vid_dur=videodata.shape[0] 
#vid_dur=20
print('Cantidad de Frames: ',vid_dur)
print('El vídeo dura: ',round((vid_dur/30)+1.7,2),'s  Aprox.' )

t=(vid_dur*96.701)/50

print('tiempo estimado: ',round(t/60,2),'min  Aprox.')

"""Elegimos el tiempo del vídeo.

> 1- Todo el vídeo

> 2- Elegir los segundos desde el principio
"""

res1='1'

while (res1!='1' or res1!='2'):
  print('ingrese valor: ')
  res1 = input(int (res1))
  if (res1=='1'):
    print('Así que quieres todo el vídeo, si miraste el tiempo que tarda?')
    vid_dur1=vid_dur
    vid_dur1 =int (vid_dur1)
    break
  if (res1=='2'):
    frames='0'
    while (frames =='0'):
      print('Cuantos segundos quieres?')
      frames=input(int (frames))
      if (frames!='0'):
        frames = int (frames)
        break

    break
  if (res1!='1' or res1!='2'):
    print('Algo salio mal, por favor digita nuevamente')

res1 = int (res1)

if (res1 == 1):
  vid_dur1=vid_dur
if (res1 == 2):
  vid_dur1=frames*30

print('Cantidad de Frames: ',vid_dur1)
print('El vídeo dura: ',round((vid_dur1/30),2),'s  Aprox.' )

t=(vid_dur1*96.701)/50

print('tiempo estimado: ',round(t/60,2),'min  Aprox.')

"""Aquí creamos los frames"""

Clusters=3 #recomendado mantener en 3

img_array=[]

for i in range(vid_dur1):
  
  image=k_imagen_grey(videodata[i],Clusters)
  
  image=arr2ascii(image,image.shape[0],image.shape[1])
  
  np.savetxt('test.txt',image,fmt='%s')
  image = text_image('test.txt')
  
  plt.figure()
  imagen = cv.bitwise_not(np.asarray(image))
  imagen_a=Image.fromarray(imagen)
  imagen_a.save(f'/content/Frames/frame_0{i}.jpg')

"""Convertir imagenes a vídeo...

Elige la calidad: 


> 1- Máxima (4K)

> 2- Default (1080p)
"""

res='1'

while (res!='1' or res!='2'):
  print('ingrese valor: ')
  res = input(int (res))
  if (res=='1'):
    print('Elegiste Máxima Calidad, espero tengas espacio para la descarga.')
    break
  if (res=='2'):
    print('Elegiste la calidad definida de 1080p, esto será rápido.')
    break
  if (res!='1' or res!='2'):
    print('Algo salio mal, por favor digita nuevamente')
res=int (res)

img_array=[]
if (res==1):
  width = int(imagen.shape[1])
  height = int(imagen.shape[0])
if (res==2):
  width=1920
  height=1080

dim = (int(width), int(height))

for i in range(vid_dur1):
  img=cv.imread(f'/content/Frames/frame_0{i}.jpg')
  
  img_s = cv.resize(img,dim)

  img_array.append(img_s)

"""Aquí se hace la mágia"""

size = (width, height)

FPS=float(30)

fourcc = cv.VideoWriter_fourcc (*'mp4v')
out = cv.VideoWriter ('Output.mp4',fourcc, FPS,size)

for i in range(len(img_array)):
    out.write(img_array[i])

out.release()
#Ouput.mp4 es el resultado y se puede descargar

"""Ahora borra las imagenes para subir un nuevo vídeo."""

for i in range(vid_dur1):
  remove(f'/content/Frames/frame_0{i}.jpg')